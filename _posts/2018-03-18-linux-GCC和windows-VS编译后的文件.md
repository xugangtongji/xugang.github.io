---
layout: post
title: linux-GCC和windows-VS编译程序
categories: 计算机系统
comments: false
description: 书籍
keywords: 编译
mathjax: true
---
### GCC编译器
GNU编译器套件。注意： GCC编译如果不指定编译选项的话是一步到位没有额外的后缀名文件！也就是只有exe执行文件。

编译的四个阶段：

-E：仅执行编译预处理；<br>
-c：仅执行编译操作，生成hello.o目标文件，不进行连接操作；<br>
-S：将C代码转换为汇编代码； <br>
-o：指定生成的输出文件，形成可执行文件test；<br>
-g: 选项产生符号调试工具，插入到生成的二进制代码中。表示编译DEBUG版本。在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。<br>
-I 选项（大写的 i）：向头文件搜索目录中添加新的目录。

**gcc –c –I /usr/dev/mysql/include test.c –o test.o**

#### Include<>与""的区别
1、用＃include"file"的时候,gcc/g++会先在当前目录查找你所制定的头文件,如果没有找到,他回到缺省的头文件目录找。如果使用-I制定了目录,他会先在你所制定的目录查找,然后再按常规的顺序去找.

2、用＃include<file>,gcc/g++会到-I制定的目录查找,查找不到,然后将到系统的缺
省的头文件目录查找。

#### 库文件连接
函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。   

Linux下的库文件分为两大类分别是动态链接库LD_LIBRARY_PATH（通常以.so结尾）和静态链接库LIBRARY_PATH（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是**在运行时动态加载的，还是在编译时静态加载的**。

#### GCC编译产生的文件类型
```
.c为后缀的文件，C语言源代码文件；
.a为后缀的文件，是由目标文件构成的档案库文件；
.cc或.cxx 为后缀的文件，是C++源代码文件且必须要经过预处理；
.h为后缀的文件，是程序所包含的头文件；
.i 为后缀的文件，是C源代码文件且不应该对其执行预处理；
.ii为后缀的文件，是C++源代码文件且不应该对其执行预处理；
.o为后缀的文件，是编译后的目标文件；
.s为后缀的文件，是汇编语言源代码文件；
.S为后缀的文件，是经过预编译的汇编语言源代码文件
```

### GCC编译器过程

![](http://p5iojc2zy.bkt.clouddn.com/_posts/_image/2018-03-18-19-12-38.jpg)

#### 一、预编译
1. 配置编译器环境。运行配置文件通常叫configure的配置文件，获取一些系统环境变量配置，编译参数，确保能在不同的系统环境下编译出的程序能正常运行！<br>
2. 头文件预编译。头文件本身是不会参与编译的，头文件会被拷贝到.c/.cpp文件里一同编译。编译并生成pch（编译好的代码），pdb（程序数据库文件）文件<br>
3. 宏替换,条件编译.把用#define定义的宏变量替换成定义值，并做条件编译判断哪些代码要编译哪些代码不需要编译！<br>
4. 词法分析。输入到分析器的缓冲区，都是通过正规则表达式来匹配给出！

#### 二、编译
1. 语法分析  
2. 代码优化  
3. 汇编。把源文件里的代码翻译成汇编指令！不同的系统使用的汇编指令不同！比如Linux和Windows所使用的汇编指令集不同，而且不同的CPU所使用的汇编指令集也是不同的！所以编译器会检查你的CPU所使用的指令集翻译成不同的汇编指令集！

#### 三、汇编
汇编指令编译成二进制文件

#### 四、链接
对一些动态库，静态库以及其它相关文件进行链接，比如printf存放于printf.o文件里那么编译器要把peintf.o和源文件进行链接合并生成可执行文件!