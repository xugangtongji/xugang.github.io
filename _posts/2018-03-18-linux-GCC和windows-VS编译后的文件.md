---
layout: post
title: linux-GCC和windows-VS编译程序
categories: 计算机系统
comments: false
description: 书籍
keywords: 编译
mathjax: true
---
### GCC编译器
GNU编译器套件。注意： GCC编译如果不指定编译选项的话是一步到位没有额外的后缀名文件！也就是只有exe执行文件。

编译的四个阶段：

-E：仅执行编译预处理；<br>
-c：仅执行编译操作，生成hello.o目标文件，不进行连接操作；<br>
-S：将C代码转换为汇编代码； <br>
-o：指定生成的输出文件，形成可执行文件test；<br>
-g: 选项产生符号调试工具，插入到生成的二进制代码中。表示编译DEBUG版本。在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。<br>
-I 选项（大写的 i）：向头文件搜索目录中添加新的目录。

**gcc –c –I /usr/dev/mysql/include test.c –o test.o**

#### Include<>与""的区别
1、用＃include"file"的时候,gcc/g++会先在当前目录查找你所制定的头文件,如果没有找到,他回到缺省的头文件目录找。如果使用-I制定了目录,他会先在你所制定的目录查找,然后再按常规的顺序去找.

2、用＃include<file>,gcc/g++会到-I制定的目录查找,查找不到,然后将到系统的缺
省的头文件目录查找。

#### 库文件连接
函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。   

Linux下的库文件分为两大类分别是动态链接库LD_LIBRARY_PATH（通常以.so结尾）和静态链接库LIBRARY_PATH（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是**在运行时动态加载的，还是在编译时静态加载的**。

#### GCC编译产生的文件类型
```
.c为后缀的文件，C语言源代码文件；
.a为后缀的文件，是由目标文件构成的档案库文件；
.cc或.cxx 为后缀的文件，是C++源代码文件且必须要经过预处理；
.h为后缀的文件，是程序所包含的头文件；
.i 为后缀的文件，是C源代码文件且不应该对其执行预处理；
.ii为后缀的文件，是C++源代码文件且不应该对其执行预处理；
.o为后缀的文件，是编译后的目标文件；
.s为后缀的文件，是汇编语言源代码文件；
.S为后缀的文件，是经过预编译的汇编语言源代码文件
```

### GCC编译器过程

![](http://p5iojc2zy.bkt.clouddn.com/_posts/_image/2018-03-18-19-12-38.jpg)

#### 一、预编译
1. 配置编译器环境。运行配置文件通常叫configure的配置文件，获取一些系统环境变量配置，编译参数，确保能在不同的系统环境下编译出的程序能正常运行！<br>
2. 头文件预编译。头文件本身是不会参与编译的，头文件会被拷贝到.c/.cpp文件里一同编译。编译并生成pch（编译好的代码），pdb（程序数据库文件）文件<br>
3. 宏替换,条件编译.把用#define定义的宏变量替换成定义值，并做条件编译判断哪些代码要编译哪些代码不需要编译！<br>
4. 词法分析。输入到分析器的缓冲区，都是通过正规则表达式来匹配给出！

#### 二、编译
1. 语法分析  
2. 代码优化  
3. 汇编。把源文件里的代码翻译成汇编指令！不同的系统使用的汇编指令不同！比如Linux和Windows所使用的汇编指令集不同，而且不同的CPU所使用的汇编指令集也是不同的！所以编译器会检查你的CPU所使用的指令集翻译成不同的汇编指令集！

#### 三、汇编
汇编指令编译成二进制文件

#### 四、链接
对一些动态库，静态库以及其它相关文件进行链接，比如printf存放于printf.o文件里那么编译器要把peintf.o和源文件进行链接合并生成可执行文件!

### windows下visual studio编译文件
1. .i文件：Visual Studio预处理之后所生成的文件，里面包含着已经完成宏替换，条件编译以及头文件包含等宏指令！

2. .s文件：把预处理文件(.i)翻译成汇编代码的文件，包括头文件包含函数语法调用全部都会翻译成汇编指令！

3. .obj文件：.obj文件是Visual Studio把汇编文件(.s)翻译成目标代码的文件，这一步会把所有的汇编代码统统翻译成CPU可认识的二进制数据！

4. .exe文件：.exe文件是Visual Studio链接之后生成的可执行文件！

5. .lib文件：.lib文件是Windows下的静态库文件！同样也是多个.o文件的集合！

6. .dll文件：.dll文件是Windows下的动态库文件！也是多个.o文件的集合！

7. .pch文件：头文件预编译文件，这里包含了已经编译好的目标文件，一般情况下Visual Studio会自动进行头文件预编译因为这样可以提高编译速率，且当你修改了头文件内容或者.cpp文件时Visual Studio会重新预编译头文件！

8. .pdb文件：Visual Studio调试时所生成的文件，pdb文件主要保存了Visual Studio调试时所需要的基本信息，例如变量名，源文件名，函数名，栈指针(帧指针)一般只会在**调试模式**下才会生成pdb文件！pdb文件必须和调试程序文件名一致！因为调试模式下Visual Studio在调试程序时加载pdb文件是根据调试程序文件名来加载的！

9. .ilk文件：当你的Visual Studio第一次使用增量链接时所生成的文件里面包含了链接信息！增量链接是根据上次一次的链接信息而编译修改后的链接部分这样可以达到提高编译速率的效果而不是重新把整个项目都编译一遍，这个时候就需要上一次的链接信息而ilk文件里保存上一次的链接信息编译器可以从ilk文件里读取！

10. .html文件：Visual Studio生成的编译日记，里面包含了编译信息！

11. .sln文件：解决方案文件，sln包含着这个项目组里所有工程文件的详细信息！

12. .suo文件：包含着该解决方案配置信息，每个解决方案里项目在Visual Studio中的配置不一样所以每次Visual Studio运行解决方案都会读取.suo文件里的用户配置信息！

13. .project文件：解决方案文件，包含着项目里所需文件！也就是说一般情况下打开这个文件Visual Studio会从这个文件中获取到这个解决方案项目组里有那些文件！然后一并加载到工程当中去！
