---
layout: post
title: C++语言基础
categories: 编程语言
comments: false
description: 
keywords: 
mathjax: true
---

面试中遇到的 C++ 语言基础试题。

1. new 与 malloc 的区别

   (1)new 是 C++ 操作符，malloc 是 C 库函数。

   (2)对于非内部数据结构的对象而言，malloc 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数，由于 malloc 是库函数而不是运算符，不在编译器的控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。

   (3)new 可以认为是 malloc 加构造函数的执行。

   (4)new 出来的是对象，而 malloc 出来的是 `(void *)`

1. 如何禁用掉拷贝构造函数与赋值操作符?

   在类里声明但是不定义。禁用后可以防止”浅拷贝”。

   附：浅拷贝指当一个类里有指针成员指向 new 出来的数据时，当用一个对象来初始化另一个对象的时候，若将数据重新 new 一个，则为深拷贝，否则为浅拷贝。浅拷贝容易造成的问题是当一个对象析构后另一个对象访问该指针会出问题。

   调用拷贝构造函数的情况:(1)一个对象以值传递的方式传入函数体(2)一个对象以值传递的方式从函数返回(3)一个对象定义时需要通过另一个对象进行初始化。

1. 一个空类，编译器会默认为它加上什么东西?

   (1)默认构造函数

   (2)拷贝构造函数

   (3)析构函数

   (4)赋值运算符

1. C++ 中向函数传递参数的方式

   (1)值传递

   (2)指针传递

   (3)引用传递

1. 666 个苹果，10 个箱子，如何放能让客人买 1-666 个苹果都直接给若干箱子就行了。

   1,2,4,8,16,32,64,128,256,155.(用程序如何实现?)

1. 二叉树的结点定义和求叶子数

   结点{数据，左右孩子指针}

   求叶子数：递归解决。

   ```cpp
   template<typename T>
   class BinTreeNode
   {
   public:
       T m_data;
       BinTreeNode* m_pLeftChild;
       BinTreeNode* m_pRightChild;

       BinTreeNode(T data): m_data(data), m_pLeftChild(NULL), m_pRightChild(NULL) {}
       ~BinTreeNode() {}
   };

   template<typename T>
   int GetLeafCount(BinTreeNode<T>* pRoot)
   {
       if (NULL == pRoot)
       {
           return 0;
       }
       else if (NULL == pRoot->m_pLeftChild && NULL == pRoot->m_pRightChild)
       {
           return 1;
       }
       else
       {
           return GetLeafCount(pRoot->m_pLeftChild)+GetLeafCount(pRoot->m_pRightChild);
       }
   }
   ```

1. 什么时候调用拷贝构造函数？什么时候调用赋值运算符？

   如果在进行赋值操作时目标对象已经取得内存，则调用赋值运算符；如果赋值操作与目标对象的内存分配是一起进行的，则调用拷贝构造函数。见如下代码：

   ```cpp
   #include <iostream>
   using namespace std;

   class demo
   {
   public:
       demo() { cout << "default constructor" << endl; }
       demo(const demo& d) { cout << "copy constructor" << endl; }
       demo& operator=(const demo& d) { cout << "= operator" << endl; }
       ~demo() {}
   };

   int main()
   {
       demo A;
       demo B;
       B = A;
       demo C = A;

       return 0;
   }
   ```

   输出结果：

   ```
   default constructor
   default constructor
   = operator
   copy constructor
   ```


### #pragma once与 #ifndef的区别

为了避免同一个文件被include多次，C/C++中有两种方式，一种是#ifndef方式，一种是#pragma once方式。在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。
1. #ifndef方式
2. #pragma once方式


![](/images/blog/2018-08-31-20-06-08.jpg)

    #ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况

    #pragma once一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。

### new、delete、malloc、free关系
delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

### 子类析构时要调用父类的析构函数吗？
析构函数调用的次序是**先**派生类的析构**后**基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。
### 多态，虚函数，纯虚函数
多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通**过继承和虚函数**来体现；在程序编译时多态性体现在**函数和运算符的重载**上；

虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。

从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。
### 在什么时候需要使用“常引用”？　
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名。

### 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?

格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }

好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以**返回一个局部变量的引用是不可取的**。因为随着该局部变量生存期的结束，相应的引用也会失效，产生error! 

注意事项：

（1）不能返回局部变量的引用。

（2）不能返回函数内部new分配的内存的引用。

（3）可以返回类成员的引用，但最好是const。

（4）流操作符重载返回值申明为“引用”的作用：

流操作符<<和>>，这两个操作符常常希望被连续使用，对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！因此，返回一个流对象引用是惟一选择。

### 重载（overload)和重写(overried “覆盖”）的区别？
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

### 有哪几种情况只能用intialization list 而不能用assignment?
答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化列表。

### 描述内存分配方式以及它们的区别?
1） 静态数据存储区域。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量，常量。

2） 在栈上创建。在执行函数时，函数参数，返回值，函数内**局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定。
### 请说出const与#define 相比，有何优点？

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1） const 常量有数据类型，而宏常量没有数据类型。

2） 编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
### 虚函数的实现机制

### stl各个容器的大概用途，时间复杂度及特点。

### 四种cast

### 

